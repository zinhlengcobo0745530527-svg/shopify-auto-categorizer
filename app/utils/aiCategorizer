import sys
import json
import torch
import torchvision.transforms as transforms
from torchvision import models
import cv2
import numpy as np
import urllib.request
from PIL import Image

# Read products JSON from stdin
products = json.load(sys.stdin)

# Load pre-trained model (ResNet18 for demonstration)
model = models.resnet18(weights=models.ResNet18_Weights.DEFAULT)
model.eval()

# Image preprocessing
preprocess = transforms.Compose([
    transforms.Resize((224, 224)),
    transforms.ToTensor(),
    transforms.Normalize(mean=[0.485, 0.456, 0.406],
                         std=[0.229, 0.224, 0.225]),
])

# Simple mapping of ImageNet classes to generic product categories
imagenet_to_category = {
    "shirt": "Clothing",
    "jeans": "Clothing",
    "sweater": "Clothing",
    "phone": "Electronics",
    "laptop": "Electronics",
    "keyboard": "Electronics",
    "mug": "Home & Kitchen",
    "bottle": "Home & Kitchen"
}

def url_to_image(url):
    """Download image from URL and convert to PIL Image"""
    try:
        resp = urllib.request.urlopen(url)
        image = np.asarray(bytearray(resp.read()), dtype="uint8")
        image = cv2.imdecode(image, cv2.IMREAD_COLOR)
        image = cv2.cvtColor(image, cv2.COLOR_BGR2RGB)
        return Image.fromarray(image)
    except:
        return None

def categorize_product(product):
    # If product has images
    image_url = None
    if product.get("images"):
        image_url = product["images"][0].get("src")
    
    if not image_url:
        # Fallback: use title only
        title = product.get("title", "").lower()
        if "shirt" in title or "jeans" in title:
            return "Clothing"
        elif "phone" in title or "laptop" in title:
            return "Electronics"
        else:
            return "Other"

    # Load image
    img = url_to_image(image_url)
    if img is None:
        return "Other"

    # Preprocess
    input_tensor = preprocess(img).unsqueeze(0)  # Add batch dimension

    with torch.no_grad():
        outputs = model(input_tensor)
        _, predicted = torch.max(outputs, 1)
        class_idx = predicted.item()
        class_name = models.ResNet18_Weights.DEFAULT.meta["categories"][class_idx].lower()

        # Map to generic category
        for key in imagenet_to_category:
            if key in class_name:
                return imagenet_to_category[key]

        return "Other"

# Apply categorization
for p in products:
    p["category"] = categorize_product(p)

# Output JSON
print(json.dumps(products))
